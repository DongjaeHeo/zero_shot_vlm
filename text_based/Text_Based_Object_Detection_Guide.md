# Text-based Object Detection 솔루션 (레거시)

## 솔루션 개요
본 모듈은 **자연어 기반 객체 탐지 기술**의 초기 구현체입니다. Google의 OWLv2 모델을 활용한 텍스트 프롬프트 기반 탐지 방식을 테스트했으나, 성능과 속도 측면에서 한계가 확인되어 **임베딩 기반 접근법**으로 전환되었습니다.

> **중요**: 현재 프로덕션 환경에서는 `src/` 디렉토리의 임베딩 기반 솔루션을 사용하고 있습니다.

## 핵심 모듈

### 1. `prompt_engineering.py` - 프롬프트 엔지니어링 엔진
텍스트 프롬프트 기반 객체 탐지의 핵심 엔진으로, 자연어 처리와 컴퓨터 비전을 결합한 고도화된 탐지 시스템입니다.

#### 핵심 기능:
- **다중 프롬프트 전략**: 객체 클래스별 최적화된 텍스트 프롬프트 세트 제공
- **실시간 객체 탐지**: OWLv2 모델 기반 고성능 텍스트-이미지 매칭
- **고급 시각화**: 클래스별 색상 구분 및 신뢰도 점수 표시
- **결과 분석**: JSON/CSV 형태의 구조화된 탐지 결과 제공

#### 프롬프트 전략 예시:
```python
QUERY_PROMPTS = {
    "Tomb": [
        "Korean burial mound",           # 한국식 고분
        "ancient tomb site",             # 고대 무덤 유적
        "grave mound",                   # 무덤 언덕
        "traditional burial mound",      # 전통적인 매장 언덕
        "burial site covered with grass" # 풀로 덮인 매장지
    ],
    "Tree": [
        "forest",                        # 숲
        "isolated tree canopy",          # 고립된 나무 수관
        "deciduous tree",                # 활엽수
        "single tall tree",              # 단일 큰 나무
        "mature oak tree"                # 성숙한 참나무
    ]
}
```

### 2. `get_GT.py` - Ground Truth 시각화
이 파일은 실제 정답 데이터(Ground Truth)를 시각화하는 도구입니다.

#### 주요 기능:
- **YOLO 형식 라벨 파싱**: YOLO 형식의 텍스트 파일을 읽어서 바운딩 박스 추출
- **클래스별 색상 구분**: 각 객체 클래스마다 고유한 색상 할당
- **이미지 리사이징**: 1008x1008 크기로 통일하여 시각화
- **통계 정보 출력**: 각 이미지별 객체 개수 및 클래스 분포 표시

#### 클래스 매핑:
```python
CLASS_NAMES = {
    0: "Tomb",        # 무덤
    1: "Tree",        # 나무
    2: "Greenhouse",  # 온실
    3: "Building",    # 건물
    4: "Field",       # 밭
    5: "Container"    # 컨테이너
}
```

### 3. Jupyter Notebook 파일들
- `simple_prediction.ipynb`: 기본적인 객체 탐지 예제
- `prediction_with_multiple_images.ipynb`: 다중 이미지 처리 예제
- `prediction_with_multiple_text.ipynb`: 다중 텍스트 프롬프트 실험
- `test.ipynb`: 테스트 및 디버깅용 노트북

## 시스템 아키텍처

### 1. 모델 구조
```
입력 이미지 (768x768) + 텍스트 프롬프트
           ↓
    OWLv2 Processor
           ↓
    OWLv2 Model (google/owlv2-large-patch14-ensemble)
           ↓
    객체 탐지 결과 (바운딩 박스 + 신뢰도 점수)
           ↓
    NMS 후처리
           ↓
    시각화 및 결과 저장
```

### 2. 데이터 흐름
1. **이미지 전처리**: EXIF 방향 보정 → 768x768 리사이징
2. **프롬프트 처리**: 각 클래스별 다중 프롬프트 적용
3. **모델 추론**: OWLv2 모델로 텍스트-이미지 매칭
4. **후처리**: NMS로 중복 제거, 임계값 필터링
5. **결과 저장**: 시각화 이미지, JSON 결과, CSV 통계

## 핵심 기술 요소

### 1. 프롬프트 엔지니어링 전략
- **다양성**: 각 클래스마다 5개의 서로 다른 프롬프트 사용
- **구체성**: "tree" 대신 "mature oak tree" 같은 구체적 표현
- **문화적 맥락**: "Korean burial mound" 같이 한국적 맥락 반영
- **시각적 특성**: "isolated tree canopy" 같이 시각적 특징 강조

### 2. 성능 최적화
- **배치 처리**: 여러 프롬프트를 순차적으로 처리
- **메모리 효율성**: GPU 메모리 사용량 최적화
- **병렬 처리**: 다중 이미지 동시 처리 가능

### 3. 결과 분석
- **정량적 평가**: 탐지 개수, 신뢰도 점수 통계
- **정성적 평가**: 시각화를 통한 탐지 품질 확인
- **비교 분석**: 프롬프트별 성능 차이 분석

## 사용 방법

### 1. 기본 실행
```bash
# 프롬프트 엔지니어링 실행
python prompt_engineering.py

# Ground Truth 시각화
python get_GT.py
```

### 2. 설정 변경
- `IMAGE_DIR`: 입력 이미지 디렉토리 경로
- `TEXT_THRESHOLD`: 탐지 신뢰도 임계값 (기본값: 0.3)
- `IOU_THRESHOLD`: NMS IoU 임계값 (기본값: 0.5)
- `TARGET_SIZE`: 이미지 크기 (기본값: 768)

### 3. 프롬프트 수정
`QUERY_PROMPTS` 딕셔너리에서 각 클래스별 프롬프트를 수정하여 성능 개선 가능

## 출력 결과

### 1. 시각화 이미지
- 각 프롬프트별 탐지 결과 이미지
- 클래스별 색상 구분된 바운딩 박스
- 신뢰도 점수 표시

### 2. JSON 결과 파일
```json
[
  {
    "label": "Tree",
    "score": 0.85,
    "box": [100.5, 200.3, 300.7, 400.9]
  }
]
```

### 3. CSV 통계 파일
- 이미지별 탐지 개수
- 프롬프트별 성능 통계
- 클래스별 분포 정보

## 텍스트 기반 접근법의 한계점

### 1. 성능 문제
- **낮은 정확도**: 프롬프트 품질에 따른 탐지 성능 편차가 큼
- **일관성 부족**: 동일한 객체라도 프롬프트에 따라 다른 결과
- **문맥 의존성**: 텍스트 표현의 모호성으로 인한 오탐지

### 2. 속도 문제
- **느린 추론**: 매번 텍스트-이미지 매칭 수행으로 인한 지연
- **메모리 비효율**: 다중 프롬프트 처리로 인한 리소스 낭비
- **확장성 제한**: 실시간 처리에 부적합

### 3. 유지보수 문제
- **프롬프트 관리**: 클래스별 최적 프롬프트 찾기 어려움
- **다국어 지원**: 언어별 프롬프트 품질 차이
- **도메인 적응**: 새로운 환경에 대한 프롬프트 재작업 필요

## 이미지 기반 검색의 한계점

### 1. 성능 vs 속도 트레이드오프
- **높은 정확도**: 텍스트 기반보다 훨씬 정확한 탐지 결과
- **Pin-pointed 결과**: 구체적인 이미지 기반 매칭으로 정밀한 탐지
- **느린 추론 속도**: 매번 OWL 모델을 통한 임베딩 추출 과정 필요

### 2. 계산 비용 문제
- **실시간 처리 불가**: 이미지당 임베딩 추출 시간으로 인한 지연
- **메모리 사용량**: 대용량 이미지 처리 시 리소스 부족
- **확장성 제한**: 대량의 이미지 처리 시 병목 현상

### 3. 운영상 한계
- **인프라 요구사항**: 고성능 GPU 및 메모리 필요
- **배치 처리 의존**: 실시간 서비스에 부적합
- **비용 증가**: 지속적인 모델 추론으로 인한 클라우드 비용 상승

## 임베딩 기반 솔루션으로의 전환

### 핵심 혁신: 사전 계산된 임베딩 저장
1. **오프라인 임베딩 추출**: 훈련 단계에서 모든 이미지의 임베딩을 미리 계산
2. **프로토타입 구축**: 클래스별 대표 임베딩 프로토타입 생성 및 저장
3. **실시간 코사인 유사도**: 저장된 임베딩과의 빠른 유사도 계산
4. **즉시 추론**: 모델 추론 없이 사전 계산된 데이터 활용

### 기술적 우위
```
텍스트 기반: 낮은 정확도 + 느린 속도
     ↓
이미지 기반: 높은 정확도 + 느린 속도  
     ↓
임베딩 기반: 높은 정확도 + 빠른 속도 ✓
```

> **결론**: 이미지 기반 접근법의 높은 정확도와 텍스트 기반의 빠른 속도를 결합한 임베딩 기반 솔루션이 최종적으로 선택되었습니다. 이는 정확도와 속도를 모두 만족하는 최적의 솔루션입니다.
